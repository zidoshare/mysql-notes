### 什么是事务

说到事务，首先想到ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）

mysql事务提供三个基本的事务指令：

* begin: 开始事务
* commit: 提交事务
* rollback: 回滚事务

#### 原子性

> 原子性概念很简单,即事务中的所有操作要么一起都完成，要么一起都不完成，不可分割。

做一个尝试，见[1.原子性](./1.原子性)

#### 一致性

> 一致性是指在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。

#### 隔离性

> 一致性是指数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。

验证代码[2.隔离性](./2.隔离性)

#### 持久性

> 持久性是指事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

### 四个隔离级别

在理解隔离界别前，我们首先要了解数据库事务所面临的问题：脏读、幻读、不可重复读

**什么是脏读、幻读、不可重复读呢？**

* 脏读：脏读是指一个事务中访问到了另外一个事务未提交的数据。理解:两个事务完全没有隔离，彼此操作都完全看得见，这就导致了并发情况下数据不一致
* 幻读：一个事务读取2次，得到的记录条数不一致。理解：两个事务隔离了对于新增、删除数据的访问。也就是说就算其他事务新增、删除了数据，我查询一个范围的时候查到的还是我事务开始时的那些数据，不会因为其他事务的增删而导致结果出错
* 不可重复读：一个事务读取同一条记录2次，得到的结果不一致。理解：两个事务隔离了同一条记录修改，也就是说就算其他事务修改了，我看到的还是之前的，这样就能保证我针对这一条数据的逻辑一定准确

**脏读、幻读、不可重复读产生了什么问题呢？**

要回答这个问题，首先应该了解并发的概念：如果我们的所有业务请求都是**原子性**的，那么我们完全不需要担心数据的操作会超出我们的预期，例如一个业务设置某个数为2，不论十个请求还是一亿个请求进来都无所谓，反正先来后到，就算你一起来都行，最终都是一步到位。但是事与愿违，几乎不可能有这么简单的业务，起码也是`先查一查数据是不是为2，如果是2就设置为4，否则设置为8`这种级别，这时候就不能不先getData(),然后setData()了，正常情况下是这样，但是如果两个请求一起进来呢？理想情况下我们觉得因该是是a请求先查询是2然后修改成4，然后b请求查询到4修改成8，或者反过来b请求先查询是2然后修改成4，然后a请求查询到4，修改成8。然而，事与愿违的是有可能a请求查了查是2，此时b请求也查了查，嗯，是2，然后b请求率先把2改成了4。此时a请求才慢悠悠的过来改数据（**因为并发情况下，没有人能预测谁会先走到哪一步**），因为之前a已经看到了是2，所以就信誓旦旦的直接设置成4。这时，问题就来了，请问，**这段逻辑是正确的吗**？

你可能会说，其实没什么问题，影响不大，他们单个的逻辑其实是正确的，也无所谓，修改个数字而已，大不了再来一次。确实，很多情况下，就是这样，没毛病，就像电脑系统出了问题大不了重启，这种情况下，虽然逻辑可能是错误的，但是最终结果其实无关紧要，这也就是**可容忍的**

但是如果把这个数字换成自己的账户，那就**不可容忍**了

从上面的问题，可以看出，我们看问题时一定要看到这个逻辑是不是可容忍的错误，然后根据开发难度（你可能是个完全不会并发的小白）、执行效率（ab之间都互相不管对方做了啥都坚持自我其实效率是最高的）、安全性（如果是我的钱包缩水那绝对不能容忍了）等方面综合评估。

mysql无法预估开发者的容忍度，而要一步到位完全解决这三个问题，那带来的效率损失不可估量，所以它为你提供了一步一步降低错误出错的方案，帮助你去做到你最想要的权衡，这也就是事务隔离性：

mysql提供了四个隔离级别：

* `Read Uncommitted`:读未提交
* `Read Committed`: 读已提交
* `Repeatable Read`: 可重复读
* `Serializable`: 串行化

根据验证[2.隔离性](./2.隔离性)所得出的结果来看，四个隔离级别对应的结果：

* [读未提交](./2.隔离性/1.读未提交)：事务1可以读取到事务2修改过但未提交的数据（产生脏读，幻读，不可重复度）
* [读已提交](./2.隔离性/2.读已提交)：事务1只能在事务2修改过并且已提交后才能读取到事务2修改的数据（产生幻读，不可重复度）
* [可重复读](./2.隔离性/3.可重复读)：事务1只能在事务2修改过数据并提交后，自己也提交事务后，才能读取到事务2修改的数据(产生幻读)
* [串行化](./2.隔离性/4.串行化)：事务1在执行过程中完全看不到事务2对数据库所做的更新。当两个事务同时操作数据库中相同数据时，如果事务1已经在访问该数据，事务2只能停下来等待，必须等到事务1结束后才能恢复运行

但是在这里我建议记忆的顺序应该是**脏读、不可重复读、幻读**，每个隔离级别依次递增的解决每一个问题，最后通过串行化，完美解决三个问题。

